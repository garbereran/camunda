{"name":"BusinessProcess.java","path":"engine-cdi/core/src/main/java/org/camunda/bpm/engine/cdi/BusinessProcess.java","content":{"structured":{"description":"a BusinessProcess class that provides methods for associating an execution with a task, starting a task, and flushing the variable cache. It also provides getters and setters for tasks, executions, and process instances. The code uses packages such as `org.flowable.engine` and `org.springframework.boot`. The main functionality of the code is to manage the associations between tasks, executions, and process instances in a workflow engine.","items":[{"id":"e98e0bba-e3db-f08a-794d-f605924552f0","ancestors":[],"type":"function","description":"provides various methods for managing the association between a task and an execution, as well as flushing the cached variables to the Task or Execution. It also provides getters and setters for the associated task and execution, and allows to flush the cached variables to the Task or Execution. The class also provides internal implementation details, such as assertions for checking the association status of tasks and executions, and a check for active command context.","name":"BusinessProcess","code":"@Named\npublic class BusinessProcess implements Serializable {\n\n  private static final long serialVersionUID = 1L;\n\n  @Inject private ProcessEngine processEngine;\n\n  @Inject private ContextAssociationManager associationManager;\n\n  @Inject private Instance<Conversation> conversationInstance;\n\n  public ProcessInstance startProcessById(String processDefinitionId) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessById(String processDefinitionId, String businessKey) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, businessKey, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessById(String processDefinitionId, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessById(String processDefinitionId, String businessKey, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, businessKey, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessByKey(String key) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessByKey(String key, String businessKey) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, businessKey, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessByKey(String key, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessByKey(String key, String businessKey, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, businessKey, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessByMessage(String messageName) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    ProcessInstance instance =  processEngine.getRuntimeService().startProcessInstanceByMessage(messageName, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessByMessage(String messageName, Map<String, Object> processVariables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(processVariables);\n    ProcessInstance instance =  processEngine.getRuntimeService().startProcessInstanceByMessage(messageName, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n  public ProcessInstance startProcessByMessage(String messageName, String businessKey, Map<String, Object> processVariables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(processVariables);\n    ProcessInstance instance =  processEngine.getRuntimeService().startProcessInstanceByMessage(messageName, businessKey, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n\n\n  /**\n   * Associate with the provided execution. This starts a unit of work.\n   *\n   * @param executionId\n   *          the id of the execution to associate with.\n   * @throw ProcessEngineCdiException\n   *          if no such execution exists\n   */\n  public void associateExecutionById(String executionId) {\n    Execution execution = processEngine.getRuntimeService()\n      .createExecutionQuery()\n      .executionId(executionId)\n      .singleResult();\n    if(execution == null) {\n      throw new ProcessEngineCdiException(\"Cannot associate execution by id: no execution with id '\"+executionId+\"' found.\");\n    }\n    associationManager.setExecution(execution);\n  }\n\n  /**\n   * returns true if an {@link Execution} is associated.\n   *\n   * @see #associateExecutionById(String)\n   */\n  public boolean isAssociated() {\n    return associationManager.getExecutionId() != null;\n  }\n\n  /**\n   * Signals the current execution, see {@link RuntimeService#signal(String)}\n   * <p/>\n   * Ends the current unit of work (flushes changes to process variables set\n   * using {@link #setVariable(String, Object)} or made on\n   * {@link BusinessProcessScoped @BusinessProcessScoped} beans).\n   *\n   * @throws ProcessEngineCdiException\n   *           if no execution is currently associated\n   * @throws ProcessEngineException\n   *           if the activiti command fails\n   */\n  public void signalExecution() {\n    assertExecutionAssociated();\n    processEngine.getRuntimeService().setVariablesLocal(associationManager.getExecutionId(), getAndClearCachedLocalVariableMap());\n    processEngine.getRuntimeService().signal(associationManager.getExecutionId(), getAndClearCachedVariableMap());\n    associationManager.disAssociate();\n  }\n\n  /**\n   * @see #signalExecution()\n   *\n   * In addition, this method allows to end the current conversation\n   */\n  public void signalExecution(boolean endConversation) {\n    signalExecution();\n    if(endConversation) {\n      conversationInstance.get().end();\n    }\n  }\n\n  // -------------------------------------\n\n  /**\n   * Associates the task with the provided taskId with the current conversation.\n   * <p/>\n   *\n   * @param taskId\n   *          the id of the task\n   *\n   * @return the resumed task\n   *\n   * @throws ProcessEngineCdiException\n   *           if no such task is found\n   */\n  public Task startTask(String taskId) {\n    Task currentTask = associationManager.getTask();\n    if(currentTask != null && currentTask.getId().equals(taskId)) {\n      return currentTask;\n    }\n    Task task = processEngine.getTaskService().createTaskQuery().taskId(taskId).singleResult();\n    if(task == null) {\n      throw new ProcessEngineCdiException(\"Cannot resume task with id '\"+taskId+\"', no such task.\");\n    }\n    associationManager.setTask(task);\n    associateExecutionById(task.getExecutionId());\n    return task;\n  }\n\n  /**\n   * @see #startTask(String)\n   *\n   * this method allows to start a conversation if no conversation is active\n   */\n  public Task startTask(String taskId, boolean beginConversation) {\n    if(beginConversation) {\n      Conversation conversation = conversationInstance.get();\n      if(conversation.isTransient()) {\n       conversation.begin();\n      }\n    }\n    return startTask(taskId);\n  }\n\n  /**\n   * Completes the current UserTask, see {@link TaskService#complete(String)}\n   * <p/>\n   * Ends the current unit of work (flushes changes to process variables set\n   * using {@link #setVariable(String, Object)} or made on\n   * {@link BusinessProcessScoped @BusinessProcessScoped} beans).\n   *\n   * @throws ProcessEngineCdiException\n   *           if no task is currently associated\n   * @throws ProcessEngineException\n   *           if the activiti command fails\n   */\n  public void completeTask() {\n    assertTaskAssociated();\n    processEngine.getTaskService().setVariablesLocal(getTask().getId(), getAndClearCachedLocalVariableMap());\n    processEngine.getTaskService().setVariables(getTask().getId(), getAndClearCachedVariableMap());\n    processEngine.getTaskService().complete(getTask().getId());\n    associationManager.disAssociate();\n  }\n\n  /**\n   * @see BusinessProcess#completeTask()\n   *\n   * In addition this allows to end the current conversation.\n   *\n   */\n  public void completeTask(boolean endConversation) {\n    completeTask();\n    if(endConversation) {\n      conversationInstance.get().end();\n    }\n  }\n\n  public boolean isTaskAssociated() {\n    return associationManager.getTask() != null;\n  }\n\n  /**\n   * Save the currently associated task.\n   *\n   * @throws ProcessEngineCdiException if called from a process engine command or if no Task is currently associated.\n   *\n   */\n  public void saveTask() {\n    assertCommandContextNotActive();\n    assertTaskAssociated();\n\n    final Task task = getTask();\n    // save the task\n    processEngine.getTaskService().saveTask(task);\n  }\n\n  /**\n   * <p>Stop working on a task. Clears the current association.</p>\n   *\n   * <p>NOTE: this method does not flush any changes.</p>\n   * <ul>\n   *  <li>If you want to flush changes to process variables, call {@link #flushVariableCache()} prior to calling this method,</li>\n   *  <li>If you need to flush changes to the task object, use {@link #saveTask()} prior to calling this method.</li>\n   * </ul>\n   *\n   * @throws ProcessEngineCdiException if called from a process engine command or if no Task is currently associated.\n   */\n  public void stopTask() {\n    assertCommandContextNotActive();\n    assertTaskAssociated();\n    associationManager.disAssociate();\n  }\n\n  /**\n   * <p>Stop working on a task. Clears the current association.</p>\n   *\n   * <p>NOTE: this method does not flush any changes.</p>\n   * <ul>\n   *  <li>If you want to flush changes to process variables, call {@link #flushVariableCache()} prior to calling this method,</li>\n   *  <li>If you need to flush changes to the task object, use {@link #saveTask()} prior to calling this method.</li>\n   * </ul>\n   *\n   * <p>This method allows you to optionally end the current conversation</p>\n   *\n   * @param endConversation if true, end current conversation.\n   * @throws ProcessEngineCdiException if called from a process engine command or if no Task is currently associated.\n   */\n  public void stopTask(boolean endConversation) {\n    stopTask();\n    if(endConversation) {\n      conversationInstance.get().end();\n    }\n  }\n\n  // -------------------------------------------------\n\n  /**\n   * @param variableName\n   *          the name of the process variable for which the value is to be\n   *          retrieved\n   * @return the value of the provided process variable or 'null' if no such\n   *         variable is set\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T getVariable(String variableName) {\n    TypedValue variable = getVariableTyped(variableName);\n    if (variable != null) {\n      Object value = variable.getValue();\n      if (value != null) {\n        return (T) value;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param variableName\n   *          the name of the process variable for which the value is to be\n   *          retrieved\n   * @return the typed value of the provided process variable or 'null' if no\n   *         such variable is set\n   *\n   * @since 7.3\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T extends TypedValue> T getVariableTyped(String variableName) {\n    TypedValue variable = associationManager.getVariable(variableName);\n    return variable != null ? (T) (variable) : null;\n  }\n\n  /**\n   * Set a value for a process variable.\n   * <p />\n   *\n   * <strong>NOTE:</strong> If no execution is currently associated,\n   * the value is temporarily cached and flushed to the process instance\n   * at the end of the unit of work\n   *\n   * @param variableName\n   *          the name of the process variable for which a value is to be set\n   * @param value\n   *          the value to be set\n   *\n   */\n  public void setVariable(String variableName, Object value) {\n    associationManager.setVariable(variableName, value);\n  }\n\n  /**\n   * Get the {@link VariableMap} of cached variables and clear the internal variable cache.\n   *\n   * @return the {@link VariableMap} of cached variables\n   *\n   * @since 7.3\n   */\n  public VariableMap getAndClearCachedVariableMap() {\n    VariableMap cachedVariables = associationManager.getCachedVariables();\n    VariableMap copy = new VariableMapImpl(cachedVariables);\n    cachedVariables.clear();\n    return copy;\n  }\n\n  /**\n   * Get the map of cached variables and clear the internal variable cache.\n   *\n   * @return the map of cached variables\n   * @deprecated use {@link #getAndClearCachedVariableMap()} instead\n   */\n  @Deprecated\n  public Map<String, Object> getAndClearVariableCache() {\n    return getAndClearCachedVariableMap();\n  }\n\n  /**\n   * Get a copy of the {@link VariableMap} of cached variables.\n   *\n   * @return a copy of the {@link VariableMap} of cached variables.\n   *\n   * @since 7.3\n   */\n  public VariableMap getCachedVariableMap() {\n    return new VariableMapImpl(associationManager.getCachedVariables());\n  }\n\n  /**\n   * Get a copy of the map of cached variables.\n   *\n   * @return a copy of the map of cached variables.\n   * @deprecated use {@link #getCachedVariableMap()} instead\n   */\n  @Deprecated\n  public Map<String, Object> getVariableCache() {\n    return getCachedVariableMap();\n  }\n\n  /**\n   * @param variableName\n   *          the name of the local process variable for which the value is to be\n   *          retrieved\n   * @return the value of the provided local process variable or 'null' if no such\n   *         variable is set\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T getVariableLocal(String variableName) {\n    TypedValue variable = getVariableLocalTyped(variableName);\n    if (variable != null) {\n      Object value = variable.getValue();\n      if (value != null) {\n        return (T) value;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param variableName\n   *          the name of the local process variable for which the value is to\n   *          be retrieved\n   * @return the typed value of the provided local process variable or 'null' if\n   *         no such variable is set\n   *\n   * @since 7.3\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T extends TypedValue> T getVariableLocalTyped(String variableName) {\n    TypedValue variable = associationManager.getVariableLocal(variableName);\n    return variable != null ? (T) variable : null;\n  }\n\n  /**\n   * Set a value for a local process variable.\n   * <p />\n   *\n   * <strong>NOTE:</strong> If a task or execution is currently associated,\n   * the value is temporarily cached and flushed to the process instance\n   * at the end of the unit of work - otherwise an Exception will be thrown\n   *\n   * @param variableName\n   *          the name of the local process variable for which a value is to be set\n   * @param value\n   *          the value to be set\n   *\n   */\n  public void setVariableLocal(String variableName, Object value) {\n    associationManager.setVariableLocal(variableName, value);\n  }\n\n  /**\n   * Get the {@link VariableMap} of local cached variables and clear the internal variable cache.\n   *\n   * @return the {@link VariableMap} of cached variables\n   *\n   * @since 7.3\n   */\n  public VariableMap getAndClearCachedLocalVariableMap() {\n    VariableMap cachedVariablesLocal = associationManager.getCachedLocalVariables();\n    VariableMap copy = new VariableMapImpl(cachedVariablesLocal);\n    cachedVariablesLocal.clear();\n    return copy;\n  }\n\n  /**\n   * Get the map of local cached variables and clear the internal variable cache.\n   *\n   * @return the map of cached variables\n   * @deprecated use {@link #getAndClearCachedLocalVariableMap()} instead\n   */\n  @Deprecated\n  public Map<String, Object> getAndClearVariableLocalCache() {\n    return getAndClearCachedLocalVariableMap();\n  }\n\n  /**\n   * Get a copy of the {@link VariableMap} of local cached variables.\n   *\n   * @return a copy of the {@link VariableMap} of local cached variables.\n   *\n   * @since 7.3\n   */\n  public VariableMap getCachedLocalVariableMap() {\n    return new VariableMapImpl(associationManager.getCachedLocalVariables());\n  }\n\n  /**\n   * Get a copy of the map of local cached variables.\n   *\n   * @return a copy of the map of local cached variables.\n   * @deprecated use {@link #getCachedLocalVariableMap()} instead\n   */\n  @Deprecated\n  public Map<String, Object> getVariableLocalCache() {\n    return getCachedLocalVariableMap();\n  }\n\n  /**\n   * <p>This method allows to flush the cached variables to the Task or Execution.<p>\n   *\n   * <ul>\n   *   <li>If a Task instance is currently associated,\n   *       the variables will be flushed using {@link TaskService#setVariables(String, Map)}</li>\n   *   <li>If an Execution instance is currently associated,\n   *       the variables will be flushed using {@link RuntimeService#setVariables(String, Map)}</li>\n   *   <li>If neither a Task nor an Execution is currently associated,\n   *       ProcessEngineCdiException is thrown.</li>\n   * </ul>\n   *\n   * <p>A successful invocation of this method will empty the variable cache.</p>\n   *\n   * <p>If this method is called from an active command (ie. from inside a Java Delegate).\n   * {@link ProcessEngineCdiException} is thrown.</p>\n   *\n   * @throws ProcessEngineCdiException if called from a process engine command or if neither a Task nor an Execution is associated.\n   */\n  public void flushVariableCache() {\n    associationManager.flushVariableCache();\n  }\n\n  // ----------------------------------- Getters / Setters\n\n  /*\n   * Note that Producers should go into {@link CurrentProcessInstance} in\n   * order to allow for specializing {@link BusinessProcess}.\n   */\n\n  /**\n   * @see #startTask(String)\n   */\n  public void setTask(Task task) {\n    startTask(task.getId());\n  }\n\n  /**\n   * @see #startTask(String)\n   */\n  public void setTaskId(String taskId) {\n    startTask(taskId);\n  }\n\n  /**\n   * @see #associateExecutionById(String)\n   */\n  public void setExecution(Execution execution) {\n    associateExecutionById(execution.getId());\n  }\n\n  /**\n   * @see #associateExecutionById(String)\n   */\n  protected void setExecutionId(String executionId) {\n    associateExecutionById(executionId);\n  }\n\n  /**\n   * Returns the id of the currently associated process instance or 'null'\n   */\n  public String getProcessInstanceId() {\n    Execution execution = associationManager.getExecution();\n    return execution != null ? execution.getProcessInstanceId() : null;\n  }\n\n  /**\n   * Returns the id of the process associated with the current lie or '0'.\n   */\n  public String getTaskId() {\n    Task task = getTask();\n    return task != null ? task.getId() : null;\n  }\n\n  /**\n   * Returns the currently associated {@link Task}  or 'null'\n   *\n   * @throws ProcessEngineCdiException\n   *           if no {@link Task} is associated. Use {@link #isTaskAssociated()}\n   *           to check whether an association exists.\n   *\n   */\n  public Task getTask() {\n    return associationManager.getTask();\n  }\n\n  /**\n   * Returns the currently associated execution  or 'null'\n   */\n  public Execution getExecution() {\n    return associationManager.getExecution();\n  }\n\n  /**\n   * @see #getExecution()\n   */\n  public String getExecutionId() {\n    Execution e = getExecution();\n    return e != null ? e.getId() : null;\n  }\n\n  /**\n   * Returns the {@link ProcessInstance} currently associated or 'null'\n   *\n   * @throws ProcessEngineCdiException\n   *           if no {@link Execution} is associated. Use\n   *           {@link #isAssociated()} to check whether an association exists.\n   */\n  public ProcessInstance getProcessInstance() {\n    Execution execution = getExecution();\n    if(execution != null && !(execution.getProcessInstanceId().equals(execution.getId()))){\n      return processEngine\n            .getRuntimeService()\n            .createProcessInstanceQuery()\n            .processInstanceId(execution.getProcessInstanceId())\n            .singleResult();\n    }\n    return (ProcessInstance) execution;\n  }\n\n  // internal implementation //////////////////////////////////////////////////////////\n\n  protected void assertExecutionAssociated() {\n    if (associationManager.getExecution() == null) {\n      throw new ProcessEngineCdiException(\"No execution associated. Call busniessProcess.associateExecutionById() or businessProcess.startTask() first.\");\n    }\n  }\n\n  protected void assertTaskAssociated() {\n    if (associationManager.getTask() == null) {\n      throw new ProcessEngineCdiException(\"No task associated. Call businessProcess.startTask() first.\");\n    }\n  }\n\n  protected void assertCommandContextNotActive() {\n    if(Context.getCommandContext() != null) {\n      throw new ProcessEngineCdiException(\"Cannot use this method of the BusinessProcess bean from an active command context.\");\n    }\n  }\n\n}","location":{"start":85,"insert":85,"offset":" ","indent":0,"comment":{"start":41,"end":84}},"item_type":"class","length":668},{"id":"a22399e9-9df5-8aa4-4a44-c6f96a66b09b","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance with the given ID, checks if it's already ended, and sets the execution status accordingly.","params":[{"name":"processDefinitionId","type_name":"String","description":"ID of the process definition to start.","complex_type":false}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process.\n\n* `processInstance`: This is an instance of the `ProcessInstance` class, representing a running process in the engine.\n* `isEnded()`: If set to `true`, it means that the process instance has been ended successfully, otherwise it's still running.\n* `getAndClearCachedVariableMap()`: This method clears the cache of variable maps for the current process instance.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance startProcessById(String processDefinitionId) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n}\n","description":"\nThe method will start a new process based on the provided `processDefinitionId`. It first makes sure that no command context is currently active, as it would be an error to use this method while a command is executing. Then it uses the `getAndClearCachedVariableMap` method to get the cached variables and clears the cache after getting them. Finally, it starts the process instance using the `startProcessInstanceById` method of the runtime service with the provided id, and if it hasn't ended yet, it sets the execution associated with the process instance as the current one."},"name":"startProcessById","code":"public ProcessInstance startProcessById(String processDefinitionId) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":96,"insert":96,"offset":" ","indent":2,"comment":null},"item_type":"method","length":9},{"id":"1d15e962-c846-64b0-2e47-95f64b55c28d","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance by its ID and business key, checks if it's already ended, and sets the execution context if necessary.","params":[{"name":"processDefinitionId","type_name":"String","description":"unique identifier of the process definition to be started.","complex_type":false},{"name":"businessKey","type_name":"String","description":"business key of the process definition being started, which is used to identify the specific process instance being initiated.","complex_type":false}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process instance.\n\n* `instance`: The ProcessInstance object representing the started process instance.\n* `isEnded()`: Indicates whether the process instance is ended or not. If the method returns an instance that is not ended, then it means that the process instance has been started successfully.\n\nThe function `assertCommandContextNotActive()` is used to ensure that the command context is not active when calling the `startProcessInstanceById` method. This is important because the command context can interfere with the proper execution of the process instance.\n\nThe `getAndClearCachedVariableMap()` method is used to retrieve and clear any cached variable map associated with the process definition ID and business key. This is done to ensure that the correct variable map is used when starting the process instance.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance startProcessById(String processDefinitionId, String businessKey) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, businessKey, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }\n","description":"\nThis method takes two parameters: a process definition ID as a string and a business key for the process instance, which is also a string. It uses the runtime service of the process engine to start an instance of the given process with the given business key. If the instance has not ended yet, it will be associated with this business process bean using setExecution()."},"name":"startProcessById","code":"public ProcessInstance startProcessById(String processDefinitionId, String businessKey) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, businessKey, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":106,"insert":106,"offset":" ","indent":2,"comment":null},"item_type":"method","length":9},{"id":"39837bf9-b6f9-8885-9b43-cccdee64e78b","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance with the specified ID and variables, retrieves the latest version of the process definition, and sets the execution of the process instance.","params":[{"name":"processDefinitionId","type_name":"String","description":"identifier of the process definition that is to be started.","complex_type":false},{"name":"variables","type_name":"Map<String, Object>","description":"map of initial variables for the started process.\n\n* Map<String, Object>: This parameter represents a map of string keys to object values, where each key-value pair represents a variable in the process instance. The objects can be any type that can be serialized and deserialized.\n* assertCommandContextNotActive(): This assertion ensures that the command context is not active before starting the process instance. It is used to prevent unintended interactions with other commands or process instances.\n* getAndClearCachedVariableMap(): This method retrieves and clears the cached variable map, which is used to store the variables for the current process instance. It ensures that the variables are only accessed once during the execution of the function.","complex_type":true}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process instance.\n\n* `ProcessInstance instance`: This is an object representing the started process instance. It contains information about the process instance, such as its ID, name, and current state.\n* `isEnded()`: This method returns a boolean indicating whether the process instance has ended or not. If the process instance has ended, it means that it has completed its execution and no further actions can be taken on it.\n* `setExecution()`: This method sets the execution of the process instance to the provided instance. It is used to associate the process instance with a specific execution, which can be useful for tracking the state of the process instance over time.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance startProcessById(String processDefinitionId, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, cachedVariables);\n    if (!instance.isEnded()) {\n        setExecution(instance);\n    }\n    return instance;\n}\n","description":"\nIn this example, the method startProcessById is called with two parameters, processDefinitionId and variables. The first parameter, processDefinitionId, is a String that refers to a process definition ID in Camunda BPMN. The second parameter is a Map of key-value pairs, which is used as input for the process instance created. \n\nThe method startProcessById checks if a command context is currently active and throws an exception if it is. Then it clears the variable map from any cached variables using getAndClearCachedVariableMap() and then puts all the variables provided in the second parameter, variables, into the variable map. The process engine's runtime service is used to create a new process instance with the specified process definition ID, passing the variable map as input. \n\nAfter creating a new process instance, the method checks if the instance has ended and sets the execution on the business process bean (setExecution()) if it hasn't. Finally, the created process instance is returned from the method."},"name":"startProcessById","code":"public ProcessInstance startProcessById(String processDefinitionId, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":116,"insert":116,"offset":" ","indent":2,"comment":null},"item_type":"method","length":11},{"id":"219b39da-0258-dfaa-324e-54040638ba01","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance with the given `processDefinitionId`, `businessKey`, and custom variables. It retrieves the cached variables, puts them into the process instance, and sets the execution status to indicate that it has been started.","params":[{"name":"processDefinitionId","type_name":"String","description":"identifier of the process definition to start.","complex_type":false},{"name":"businessKey","type_name":"String","description":"unique identifier of the business process to be started.","complex_type":false},{"name":"variables","type_name":"Map<String, Object>","description":"map of variables to be passed to the started process instance, which are then added to the cache and used to initialize the process instance.\n\n* `Map<String, Object> variables`: This is a map that contains key-value pairs representing the input variables for the process instance. The keys are strings, and the values can be any type of object.\n* `processDefinitionId`: The ID of the process definition to start.\n* `businessKey`: The business key of the process instance to start.\n* `getAndClearCachedVariableMap()`: This is a method that retrieves the cached variable map and clears it, which is necessary before starting a new process instance.","complex_type":true}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process.\n\n* `instance`: A `ProcessInstance` object representing the started process instance.\n* `isEnded()`: Indicates whether the process instance has ended or not. If it has, the method sets the execution to indicate that the process is over.\n\nThe output of the function is an instance of the `ProcessInstance` class, which contains information about the started process instance, including its ID, name, and current state.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance startProcessById(String processDefinitionId, String businessKey, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, businessKey, cachedVariables);\n    if (!instance.isEnded()) {\n        setExecution(instance);\n    }\n    return instance;\n}\n","description":"\nThe input variables are:\n* processDefinitionId: The id of the process to start\n* businessKey: A unique key that identifies the Process Instance in the context of a particular business transaction or use case. Mandatory if the process has one or more variable listeners or if the process is started from the REST API or a file\n* variables: A map of parameters that can be passed to the process instance, such as name/value pairs for human task inputs\n\nThe method will first assert that there is no active command context. If there is, an error message will be thrown because this method cannot be used from within a command context.\n\nNext, we get and clear the cached variable map. This variable map contains any variables that were previously set using the setVariable methods, but these values are not yet written to the database. By putting all input variables into the cached variable map, we ensure they are written to the database when startProcessInstanceById is called.\n\nWe then call the startProcessInstanceById method on our process engine's runtime service with the given process definition id, business key, and variable map as parameters. This will start a new process instance based on the given process definition id and set the variables on the process instance accordingly.\n\nFinally, if the started process instance has not ended yet (i.e., it is currently in progress), we set the execution to the newly created process instance so that the current business process can continue interacting with it using the various methods available for the execution bean."},"name":"startProcessById","code":"public ProcessInstance startProcessById(String processDefinitionId, String businessKey, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceById(processDefinitionId, businessKey, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":128,"insert":128,"offset":" ","indent":2,"comment":null},"item_type":"method","length":11},{"id":"33aa5118-a7da-d184-414f-e284dfc817ff","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance using its key, checks if it is already ended, and sets the execution context to the started instance if not.","params":[{"name":"key","type_name":"String","description":"process instance key that is being started.","complex_type":false}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process.\n\n* `ProcessInstance instance`: This is the ProcessInstance object that represents the started process. It has various attributes and methods that can be used to interact with the process instance.\n* `isEnded()`: This method returns a boolean value indicating whether the process instance is ended or not. If the process instance is ended, it means that the process has completed successfully or failed.\n* `getAndClearCachedVariableMap()`: This method retrieves and clears any cached variable map for the process instance. The variable map contains information about the variables in the process instance, which can be useful for further processing or analysis.","complex_type":true},"usage":{"language":"java","code":"// Start a new process instance using the process key 'my-process' and pass variables to it\nbusinessProcess.startProcessByKey(\"my-process\", \"myVariable1\", \"My value 1\", \"myVariable2\", \"My value 2\");\n","description":"\nThis example calls the startProcessByKey method on the BusinessProcess bean, passing in two variable values using the key 'myVariable1' and 'myVariable2'. The method would return a new ProcessInstance object that represents the started process. This object could then be used to manage the execution of the process instance."},"name":"startProcessByKey","code":"public ProcessInstance startProcessByKey(String key) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":140,"insert":140,"offset":" ","indent":2,"comment":null},"item_type":"method","length":9},{"id":"2465fc16-727e-b5aa-3740-72b9588ab97e","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance by key and retrieves it from the process engine. It also sets the execution status to indicate that the process has been started.","params":[{"name":"key","type_name":"String","description":"process instance key to start.","complex_type":false},{"name":"businessKey","type_name":"String","description":"business key of the process instance to be started, which is used to identify the process instance uniquely within the context of the application.","complex_type":false}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process.\n\n* `instance`: A `ProcessInstance` object representing the started process instance.\n* `isEnded`: Whether the process instance is ended or not. If it's not ended, the execution is set.\n\nThe `startProcessByKey` function first asserts that the command context is not active before starting the process instance using the `getRuntimeService()` method and calling the `startProcessInstanceByKey()` method to retrieve the started process instance. The `getAndClearCachedVariableMap()` method is then called to clear any cached variable map.","complex_type":true},"usage":{"language":"java","code":"String key = \"My process key\";\nString businessKey = \"My business key\";\n\n// The variable map is cleared and returned to the cache\nMap<String, Object> variables = businessProcess.getAndClearCachedVariableMap();\n\nvariables.put(\"myInputParameter\", \"input value\");\n\nProcessInstance instance = businessProcess.startProcessByKey(key, businessKey);\n\n// The variable map is cleared and returned to the cache\nvariables = businessProcess.getAndClearCachedVariableMap();\n","description":""},"name":"startProcessByKey","code":"public ProcessInstance startProcessByKey(String key, String businessKey) {\n    assertCommandContextNotActive();\n\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, businessKey, getAndClearCachedVariableMap());\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":150,"insert":150,"offset":" ","indent":2,"comment":null},"item_type":"method","length":9},{"id":"5a9e504c-2d7e-2ba4-6047-2f9e108401b6","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance by key and sets the execution status to ongoing if the instance is not ended.","params":[{"name":"key","type_name":"String","description":"process definition key used to start a new process instance.","complex_type":false},{"name":"variables","type_name":"Map<String, Object>","description":"map of variable values to be used when starting a process instance by its key, and is passed to the `startProcessInstanceByKey()` method of the `processEngine` to provide the necessary context for the process instance startup.\n\n* `Map<String, Object> variables`: This map contains key-value pairs representing the variables to be passed to the start process instance. Each key corresponds to a variable name, and the value is the actual value of that variable. The values can be any valid Java object type, such as integers, strings, dates, or other complex data types.\n* `assertCommandContextNotActive()`: This method checks if the command context is already active, and if so, it throws an exception to prevent multiple instances from being created.\n* `getAndClearCachedVariableMap()`: This method retrieves a copy of the cached variable map and then clears the cache to ensure that only the latest variables are used for the start process instance.","complex_type":true}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process.\n\n* `ProcessInstance`: This is the object representing the started process instance. It contains information such as the process ID, the process definition ID, and the current state of the process instance.\n* `isEnded()`: This method checks whether the process instance has ended or not. If it has ended, the method returns `true`, otherwise it returns `false`.\n* `getExecution()`: This method retrieves the execution of the started process instance. It is a wrapper around the actual execution object, which provides access to various information related to the execution, such as the ID, the current state, and the like.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance startProcessByKey(String key, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n    \n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n}\n","description":"\nThe method takes two arguments: key and variables. Key is a String representing the process definition key, while variables is a Map<String, Object> of variable name-value pairs to be passed to the process when it starts. It then uses assertCommandContextNotActive() to ensure that this method cannot be used inside an active command context. getAndClearCachedVariableMap() clears any cached variables and returns them as a VariableMap.\nAfterwards, it starts a new instance of the process by key using the variables in the map. If the started process has not ended, setExecution(instance) sets this newly created execution as the current execution for this BusinessProcess bean. Finally, it returns the ProcessInstance that was just started."},"name":"startProcessByKey","code":"public ProcessInstance startProcessByKey(String key, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":160,"insert":160,"offset":" ","indent":2,"comment":null},"item_type":"method","length":11},{"id":"05ceb6f0-de1f-c3a1-2744-9fc668e1cafb","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance by its key and initializes variables with provided map. It then checks if the process instance is already ended, sets execution to it and returns the instance if not.","params":[{"name":"key","type_name":"String","description":"unique process instance identifier that is used to start a new instance of a process.","complex_type":false},{"name":"businessKey","type_name":"String","description":"unique identifier of the process instance to start, which is used to locate the appropriate process definition and activate its execution.","complex_type":false},{"name":"variables","type_name":"Map<String, Object>","description":"map of variables to be passed to the startProcessInstanceByKey method, which is used to initialize the process instance with the specified key and business key.\n\n* `String key`: The unique process instance ID to start.\n* `String businessKey`: The business key identifying the process instance.\n* `Map<String, Object> variables`: A map of variable names and values passed from the caller to customize the process instance startup. The keys in the map are case-sensitive strings, while the values can be any Java object type.","complex_type":true}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process.\n\n* `instance`: The ProcessInstance object representing the started process instance.\n* `isEnded()`: A boolean indicating whether the process instance is ended or not. If it is ended, then the execution is set to the instance.\n\nThe function first asserts that the command context is not active before starting the process instance using the `getRuntimeService().startProcessInstanceByKey` method and passing in the key, business key, and cached variables. After starting the instance, it checks whether the instance is ended and sets the execution to the instance if it is not ended. The returned output is an instance of `ProcessInstance`.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance startProcessByKey(String key, String businessKey, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n    \n    // Get the cached variable map from the current BusinessProcess bean\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    \n    // Start a new process instance with the provided key, business key and variables\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, businessKey, cachedVariables);\n    \n    // If the process instance is not ended, associate it to the current BusinessProcess bean\n    if (!instance.isEnded()) {\n        setExecution(instance);\n    }\n    \n    return instance;\n}\n","description":"\nThis example shows how the startProcessByKey method of the BusinessProcess class would be used in a Java client. The method starts a new process instance with the provided key, business key and variables. If the process instance is not ended, it associates the execution with the current BusinessProcess bean. The getAndClearCachedVariableMap method clears the cached variable map from the current BusinessProcess bean and returns it. This allows for the variable map to be reused in a new process instance without having to create a new map.\n\nThe example input parameters are:\n\n* key - the key of the process definition to start\n* businessKey - the business key used for the started process instance\n* variables - the variables that should be passed to the process instance when it is started\n\nThe method returns an instance of the ProcessInstance class, which contains information about the started process instance."},"name":"startProcessByKey","code":"public ProcessInstance startProcessByKey(String key, String businessKey, Map<String, Object> variables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(variables);\n    ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByKey(key, businessKey, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":172,"insert":172,"offset":" ","indent":2,"comment":null},"item_type":"method","length":11},{"id":"f614c4eb-e031-0193-da47-b5512dde8a6b","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance by sending a message to the process engine. It retrieves and clears any cached variables, passes the message name to the runtime service for processing, and sets the execution state of the resulting process instance.","params":[{"name":"messageName","type_name":"String","description":"name of the message to be started.","complex_type":false}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process.\n\n* `ProcessInstance`: The instance of the process that was started by the message.\n* `isEnded()`: A boolean indicating whether the process instance has ended or not. If it has ended, the method will have set `execution` to the instance.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance startProcessByMessage(String messageName) {\n  assertCommandContextNotActive();\n  \n  VariableMap cachedVariables = getAndClearCachedVariableMap();\n  ProcessInstance instance = processEngine.getRuntimeService().startProcessInstanceByMessage(messageName, cachedVariables);\n  if (!instance.isEnded()) {\n    setExecution(instance);\n  }\n  return instance;\n}\n","description":"\nIn this example, the method assertCommandContextNotActive checks that no active command context exists. This is necessary because it would not be possible to use this method from within an already active command context. The method getAndClearCachedVariableMap retrieves and clears a variable map of cached variables for use in the startProcessByMessage method, and sets the execution associated with the process instance returned by the startProcessInstanceByMessage method."},"name":"startProcessByMessage","code":"public ProcessInstance startProcessByMessage(String messageName) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    ProcessInstance instance =  processEngine.getRuntimeService().startProcessInstanceByMessage(messageName, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":184,"insert":184,"offset":" ","indent":2,"comment":null},"item_type":"method","length":10},{"id":"7269ca88-02b3-028e-5645-599835a547e7","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance by message name and provides process variables to the runtime service, which then creates and starts the instance if not ended.","params":[{"name":"messageName","type_name":"String","description":"name of the message that triggers the start of the process instance.","complex_type":false},{"name":"processVariables","type_name":"Map<String, Object>","description":"map of variables that will be used to start the process instance.\n\n* `String messageName`: The name of the message to start the process instance for.\n* `Map<String, Object> processVariables`: A map containing the variables that will be passed to the process instance when it is started.","complex_type":true}],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the started process.\n\n* `instance`: A `ProcessInstance` object representing the newly started process instance.\n* `isEnded()`: A boolean indicating whether the process instance has ended or not. If it has ended, the instance is set to `true`, otherwise it is set to `false`.","complex_type":true},"usage":{"language":"java","code":"public class MyBean {\n    @Inject\n    private BusinessProcess businessProcess;\n\n    public void myMethod() {\n        // Start the process instance by message and add some variables to it\n        Map<String, Object> variables = new HashMap<>();\n        variables.put(\"myVar\", \"Hello\");\n        ProcessInstance instance = businessProcess.startProcessByMessage(\"MyMessageName\", variables);\n\n        // Get the started process instance\n        if (instance != null) {\n            System.out.println(\"Process started: \" + instance.getId());\n        } else {\n            System.out.println(\"No process started\");\n        }\n    }\n}\n","description":""},"name":"startProcessByMessage","code":"public ProcessInstance startProcessByMessage(String messageName, Map<String, Object> processVariables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(processVariables);\n    ProcessInstance instance =  processEngine.getRuntimeService().startProcessInstanceByMessage(messageName, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":195,"insert":195,"offset":" ","indent":2,"comment":null},"item_type":"method","length":11},{"id":"09319dde-404b-eea5-0541-78f1b6befe09","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"starts a process instance by sending a message with the specified name and business key, passing in the necessary process variables and retrieving the resulting process instance.","params":[{"name":"messageName","type_name":"String","description":"name of the message to start the process instance with.","complex_type":false},{"name":"businessKey","type_name":"String","description":"unique identifier of the business process to which the message belongs.","complex_type":false},{"name":"processVariables","type_name":"Map<String, Object>","description":"variable values that will be passed to the started process instance, which can be used to configure or customize the process execution.\n\n* `String messageName`: The name of the message to start a process instance for.\n* `String businessKey`: A unique identifier for the process instance.\n* `Map<String, Object> processVariables`: A map of variables passed from the caller to the function, which are then used to initialize the new process instance.","complex_type":true}],"returns":{"type_name":"ProcessInstance","description":"a ProcessInstance object representing the newly started process.\n\n* `ProcessInstance instance`: This is an object representing a process instance that has been started by the message. It contains information about the process instance such as its ID, name, and current state.\n* `isEnded()`: This is a boolean property that indicates whether the process instance has ended or not. If the process instance is ended, then the function has successfully completed.\n\nThe output of the function can be destructured by accessing the properties of the `ProcessInstance` object using dot notation. For example, to access the ID of the process instance, one can use `instance.getId()`.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance startProcessByMessage(String messageName, String businessKey, Map<String, Object> processVariables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(processVariables);\n    ProcessInstance instance =  processEngine.getRuntimeService().startProcessInstanceByMessage(messageName, businessKey, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n}\n","description":"\nThe method takes three arguments: the message name (`messageName`), business key (`businessKey`) and map of process variables (`processVariables`). It first makes sure that a command context is not active. This ensures that this method cannot be called from within another command context, which would cause problems with variable caching.\n\nNext, it gets the cached variable map, adds the given process variables to it, and clears the cache. The `getAndClearCachedVariableMap` method returns a copy of the internal cache, which is then cleared. This means that any changes made to this copy will not affect the actual process instance started by the engine.\n\nThen, the engine starts the process using the given message name and business key, with the cached variables as input. If the started process instance has not ended yet (i.e., it is still active), the execution is associated with the `BusinessProcess` bean for further usage. Finally, the method returns the started process instance."},"name":"startProcessByMessage","code":"public ProcessInstance startProcessByMessage(String messageName, String businessKey, Map<String, Object> processVariables) {\n    assertCommandContextNotActive();\n\n    VariableMap cachedVariables = getAndClearCachedVariableMap();\n    cachedVariables.putAll(processVariables);\n    ProcessInstance instance =  processEngine.getRuntimeService().startProcessInstanceByMessage(messageName, businessKey, cachedVariables);\n    if (!instance.isEnded()) {\n      setExecution(instance);\n    }\n    return instance;\n  }","location":{"start":207,"insert":207,"offset":" ","indent":2,"comment":null},"item_type":"method","length":11},{"id":"fa92ded5-71b7-08b5-5d4f-c00cad202488","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves an execution instance from the process engine based on its ID, and sets it as the current execution managed by the association manager.","params":[{"name":"executionId","type_name":"String","description":"ID of the execution to be associated with the given \nassociation manager.","complex_type":false}],"usage":{"language":"java","code":"// Assume that the variable executionId has been set to a valid ID for a running process instance\nassociationManager.associateExecutionById(executionId);\n","description":"\nThis code associates the current BusinessProcess bean with the given execution ID, which is obtained from a running process instance in the process engine. The method throws an exception if no such execution exists. After associating the business process with the given execution, any subsequent calls to this method will result in that business process being associated with the same execution ID."},"name":"associateExecutionById","code":"public void associateExecutionById(String executionId) {\n    Execution execution = processEngine.getRuntimeService()\n      .createExecutionQuery()\n      .executionId(executionId)\n      .singleResult();\n    if(execution == null) {\n      throw new ProcessEngineCdiException(\"Cannot associate execution by id: no execution with id '\"+executionId+\"' found.\");\n    }\n    associationManager.setExecution(execution);\n  }","location":{"start":228,"insert":228,"offset":" ","indent":2,"comment":{"start":219,"end":227}},"item_type":"method","length":10},{"id":"d6e33e4d-ff9f-8cbc-c143-389a97ec4d5d","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"checks if an execution ID is provided by association manager. If it is, the function returns `true`, otherwise it returns `false`.","params":[],"returns":{"type_name":"boolean","description":"a boolean value indicating whether an execution ID is present.","complex_type":false},"usage":{"language":"java","code":"public boolean isAssociated() {\n    return associationManager.getExecutionId() != null;\n}\n","description":"\nThis code checks if the execution id is set in the association manager. If it is, then a task is associated and the method returns true. If not, false is returned. This way the method can be used to check whether or not a task is associated with the business process."},"name":"isAssociated","code":"public boolean isAssociated() {\n    return associationManager.getExecutionId() != null;\n  }","location":{"start":244,"insert":244,"offset":" ","indent":2,"comment":{"start":238,"end":243}},"item_type":"method","length":3},{"id":"e6b9171b-8e4f-b392-9a47-3d8495d343b1","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"asserts execution association, sets local variables on a process instance, signals the associated event, and disassociates the execution from its parent process.","params":[],"usage":{"language":"java","code":"public void signalExecution() {\n    assertExecutionAssociated();\n    processEngine.getRuntimeService().setVariablesLocal(associationManager.getExecutionId(), getAndClearCachedLocalVariableMap());\n    processEngine.getRuntimeService().signal(associationManager.getExecutionId(), getAndClearCachedVariableMap());\n    associationManager.disAssociate();\n}\n","description":"\nNote: The method assertExecutionAssociated() is called, which confirms that an execution is associated with the current businessProcess instance. If this is not the case, a ProcessEngineCdiException is thrown.\n\nThe next step is to set any local variables using the processEngine.getRuntimeService().setVariablesLocal method. This method takes two parameters: the first parameter is the id of the execution to which the variable should be applied, and the second is a map containing the key/value pairs for the variables that need to be set.\n\nAfter setting any local variables, the processEngine.getRuntimeService().signal method is called with the id of the execution as its first parameter. This triggers the execution to move forward, but it does not complete the process. The second parameter of this method is a map containing the key/value pairs for the global variables that need to be set.\n\nFinally, the method associationManager.disAssociate() is called, which removes any associations between the current businessProcess instance and the execution or task associated with it."},"name":"signalExecution","code":"public void signalExecution() {\n    assertExecutionAssociated();\n    processEngine.getRuntimeService().setVariablesLocal(associationManager.getExecutionId(), getAndClearCachedLocalVariableMap());\n    processEngine.getRuntimeService().signal(associationManager.getExecutionId(), getAndClearCachedVariableMap());\n    associationManager.disAssociate();\n  }","location":{"start":260,"insert":260,"offset":" ","indent":2,"comment":{"start":247,"end":259}},"item_type":"method","length":6},{"id":"ae20a50b-e806-4e85-6046-dd93b31d511a","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"signals the end of a conversation instance, if the argument `endConversation` is true.","params":[{"name":"endConversation","type_name":"boolean","description":"conclusion of a conversation, which is implemented by calling the `end()` method on the `conversationInstance`.","complex_type":false}],"usage":{"language":"java","code":"public void signalExecution(boolean endConversation) {\n    signalExecution();\n    if(endConversation) {\n      conversationInstance.get().end();\n    }\n  }\n","description":"\nThis method calls the signalExecution() method and checks whether the boolean endConversation is true or not. If it is, then the end() method of the current Conversation instance will be called. This method ends the current Conversation if endConversation is true.  \nThe following example shows how this method would be used:\n"},"name":"signalExecution","code":"public void signalExecution(boolean endConversation) {\n    signalExecution();\n    if(endConversation) {\n      conversationInstance.get().end();\n    }\n  }","location":{"start":272,"insert":272,"offset":" ","indent":2,"comment":{"start":266,"end":271}},"item_type":"method","length":6},{"id":"4b9dc98a-fbfb-7198-5748-23babc22dd3f","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a task by ID, creates a new task if none exists with that ID, and associates the execution with the task.","params":[{"name":"taskId","type_name":"String","description":"id of the task to be resumed, and it is used to retrieve the task from the process engine or to create a new task if it does not exist.","complex_type":false}],"returns":{"type_name":"instance","description":"a reference to the task with the specified ID, or an exception if the task does not exist.\n\nThe function returns a `Task` object, which represents a task instance in the process engine. The `Task` object has several attributes, including `id`, `name`, `description`, `owner`, `priority`, and `status`.\n\nThe `id` attribute is a unique identifier for the task, while `name` and `description` provide a human-readable name and description of the task. The `owner` attribute specifies the user who created or assigned the task, while `priority` represents the task's priority level. Finally, the `status` attribute indicates the current state of the task, such as \"active\" or \"completed\".\n\nOverall, the `startTask` function returns a Task object that contains essential information about the task instance being started.","complex_type":true},"usage":{"language":"java","code":"public void someMethod() {\n    Task task = businessProcess.startTask(\"taskId\");\n    // do something with the task here\n}\n","description":"\nIn this case, the input to `startTask` is a string which corresponds to the task's ID. This method will return a reference to that task, and it will set it as the current task for any subsequent operations (such as setting variable values or completing the task). Additionally, this method will also set the execution to the same one associated with the specified task."},"name":"startTask","code":"public Task startTask(String taskId) {\n    Task currentTask = associationManager.getTask();\n    if(currentTask != null && currentTask.getId().equals(taskId)) {\n      return currentTask;\n    }\n    Task task = processEngine.getTaskService().createTaskQuery().taskId(taskId).singleResult();\n    if(task == null) {\n      throw new ProcessEngineCdiException(\"Cannot resume task with id '\"+taskId+\"', no such task.\");\n    }\n    associationManager.setTask(task);\n    associateExecutionById(task.getExecutionId());\n    return task;\n  }","location":{"start":293,"insert":293,"offset":" ","indent":2,"comment":{"start":280,"end":292}},"item_type":"method","length":13},{"id":"7758e50e-574c-869e-e74c-62c515d0808e","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"begins a task conversation if necessary and then starts the task with the specified ID.","params":[{"name":"taskId","type_name":"String","description":"unique identifier for the task to be started.","complex_type":false},{"name":"beginConversation","type_name":"boolean","description":"state of conversations, with a value of `true` indicating that a conversation should be initiated if it is transient, and a value of `false` otherwise.","complex_type":false}],"returns":{"type_name":"Task","description":"a Task object, which represents the task to be executed.\n\n* The task ID is passed as an argument in the function call.\n* The function checks whether the conversation is transient or not before beginning it.\n* If the conversation is transient, the function begins it.\n* The function then returns the `startTask` method's output, which is a Task object.","complex_type":true},"usage":{"language":"java","code":"public Task startTask(String taskId, boolean beginConversation) {\n    // If the user decides to begin a conversation...\n    if (beginConversation) {\n        // Get the current conversation object.\n        Conversation conversation = conversationInstance.get();\n        \n        // Check if the conversation is transient.\n        if(conversation.isTransient()) {\n            // Begin the conversation.\n            conversation.begin();\n        }\n    }\n    \n    // Start the task with the given taskId.\n    return startTask(taskId);\n}\n","description":""},"name":"startTask","code":"public Task startTask(String taskId, boolean beginConversation) {\n    if(beginConversation) {\n      Conversation conversation = conversationInstance.get();\n      if(conversation.isTransient()) {\n       conversation.begin();\n      }\n    }\n    return startTask(taskId);\n  }","location":{"start":312,"insert":312,"offset":" ","indent":2,"comment":{"start":306,"end":311}},"item_type":"method","length":9},{"id":"988f02be-f34e-fa91-1349-43cfa6df6eca","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"completes a task by setting local and inherited variable values, disassociating an associated task, and marking the task as completed in the process engine.","params":[],"usage":{"language":"java","code":"public void completeTask() {\n    assertTaskAssociated();\n    processEngine.getTaskService().setVariablesLocal(getTask().getId(), getAndClearCachedLocalVariableMap());\n    processEngine.getTaskService().setVariables(getTask().getId(), getAndClearCachedVariableMap());\n    processEngine.getTaskService().complete(getTask().getId());\n    associationManager.disAssociate();\n  }\n","description":"\nExplanation: The method first asserts that a task is associated with the BusinessProcess instance by checking if it has an active task associated. This can be done using the getTask() method. If there is no task associated, then an exception is thrown. Next, the method sets local and global variables for the task associated using the setVariablesLocal and setVariables methods of the TaskService class. These methods take two arguments: the id of the task to which the variable applies; a map containing the key-value pairs for the variables to be set. Then, it completes the task that was previously associated with this business process instance using the complete() method of the TaskService class. Finally, it disassociates the BusinessProcess instance from the current task using the disAssociate() method of the AssociationManager class.\nIn conclusion, this code should be used to complete a task that has been associated with this BusinessProcess instance. It first checks if there is an active task associated with this BusinessProcess instance; if not, it throws an exception. Then, it sets variables for the task using the setVariablesLocal and setVariables methods. Finally, it completes the task associated with this business process instance using the complete() method."},"name":"completeTask","code":"public void completeTask() {\n    assertTaskAssociated();\n    processEngine.getTaskService().setVariablesLocal(getTask().getId(), getAndClearCachedLocalVariableMap());\n    processEngine.getTaskService().setVariables(getTask().getId(), getAndClearCachedVariableMap());\n    processEngine.getTaskService().complete(getTask().getId());\n    associationManager.disAssociate();\n  }","location":{"start":334,"insert":334,"offset":" ","indent":2,"comment":{"start":321,"end":333}},"item_type":"method","length":7},{"id":"efcf04f1-b265-b39d-7e46-cd07355b8fe1","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"completes a task and ends a conversation if the parameter `endConversation` is true.","params":[{"name":"endConversation","type_name":"boolean","description":"conclusion of an ongoing conversation, triggering the termination of the related conversation instance when set to `true`.","complex_type":false}],"usage":{"language":"java","code":"public class MyBean {\n    @Inject private BusinessProcess businessProcess;\n    public void myMethod() {\n        businessProcess.completeTask(true); // Complete task and end conversation\n    }\n}\n","description":""},"name":"completeTask","code":"public void completeTask(boolean endConversation) {\n    completeTask();\n    if(endConversation) {\n      conversationInstance.get().end();\n    }\n  }","location":{"start":348,"insert":348,"offset":" ","indent":2,"comment":{"start":341,"end":347}},"item_type":"method","length":6},{"id":"9a28e5f2-6726-7bab-a54c-8a0601dccc1c","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"checks if a task is associated with an entity by checking the value returned by the `associationManager.getTask()` method.","params":[],"returns":{"type_name":"boolean","description":"a boolean value indicating whether a task is associated with the current execution.","complex_type":false},"usage":{"language":"java","code":"public boolean isTaskAssociated() {\n    return associationManager.getTask() != null;\n}\n","description":"\nThis code checks whether the task associated with the current business process instance is null. If it is not null, then a task is associated and the method returns true. Otherwise, if the task is null, then no task is associated and the method returns false. This code uses the getTask() method of the association manager to retrieve the associated task and checks if it is null or not. The associated task would be null if no task is associated with the current business process instance, so in this case the method would return false."},"name":"isTaskAssociated","code":"public boolean isTaskAssociated() {\n    return associationManager.getTask() != null;\n  }","location":{"start":355,"insert":355,"offset":" ","indent":2,"comment":null},"item_type":"method","length":3},{"id":"60118340-ded0-4b97-2b44-7366600a43d7","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"validates that a command context is not active and that a task is associated with the current process instance. It then saves the task to the Process Engine's Task Service.","params":[],"usage":{"language":"java","code":"public void saveTask() {\n    assertCommandContextNotActive();\n    assertTaskAssociated();\n\n    final Task task = getTask();\n    // save the task\n    processEngine.getTaskService().saveTask(task);\n}\n","description":"\nIn this example, we first verify that there is no active command context. If there were, it would throw an exception because we are not allowed to use BusinessProcess methods from within an active command context. We then verify that a task has been associated with the BusinessProcess object. If none have been associated, it throws an error message.\n\nWe then retrieve the task from the process engine's Task Service and save it using the saveTask() method of the TaskService class."},"name":"saveTask","code":"public void saveTask() {\n    assertCommandContextNotActive();\n    assertTaskAssociated();\n\n    final Task task = getTask();\n    // save the task\n    processEngine.getTaskService().saveTask(task);\n  }","location":{"start":365,"insert":365,"offset":" ","indent":2,"comment":{"start":358,"end":364}},"item_type":"method","length":8},{"id":"eea6b1f2-1238-bebb-dd43-5ed55709c16b","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"1) ensures the command context is not active, 2) verifies the task is associated with a command, and 3) disassociates the task from the command.","params":[],"usage":{"language":"java","code":"public void stopTask() {\n    assertCommandContextNotActive();\n    assertTaskAssociated();\n    associationManager.disAssociate();\n}\n","description":"\nThis method first checks that the command context is not active using assertCommandContextNotActive(). It then asserts that a task is associated using assertTaskAssociated(). Finally, it disassociates the task by calling disAssociate() on the association manager."},"name":"stopTask","code":"public void stopTask() {\n    assertCommandContextNotActive();\n    assertTaskAssociated();\n    associationManager.disAssociate();\n  }","location":{"start":385,"insert":385,"offset":" ","indent":2,"comment":{"start":373,"end":384}},"item_type":"method","length":5},{"id":"3078695e-34ed-90b6-3f4c-6635bc8d03d3","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"stops a task and ends a conversation, respectively.","params":[{"name":"endConversation","type_name":"boolean","description":"conversation instance which will end if it's set to `true`.","complex_type":false}],"usage":{"language":"java","code":"businessProcess.stopTask(false); // false means do not end conversation. \n","description":"\nIn this example, the method businessProcess.stopTask() is called with a boolean parameter of false. This tells the method to not end the conversation. The rest of the code for stopTask is shown below:\n"},"name":"stopTask","code":"public void stopTask(boolean endConversation) {\n    stopTask();\n    if(endConversation) {\n      conversationInstance.get().end();\n    }\n  }","location":{"start":405,"insert":405,"offset":" ","indent":2,"comment":{"start":390,"end":404}},"item_type":"method","length":6},{"id":"e56ec3ed-f8f7-c5a5-7a4e-dad78bf8efb4","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a variable from a source and returns it as an object of type `T`. If the variable is not found or its value is null, the function returns `null`.","params":[{"name":"variableName","type_name":"String","description":"name of a variable that is retrieved from the component's state.","complex_type":false}],"returns":{"type_name":"T","description":"a typed value of type `T`, or `null` if the variable is not found.\n\nThe function returns an object of type `T`, which can be any subtype of `T`.\nThe function first checks if the `TypedValue` object returned by `getVariableTyped` is null. If it is not null, the function proceeds to check if the value property of the TypedValue object is not null. If it is not null, the function returns a casted version of the value to the desired type `T`.\nIf either of these conditions is true, the function returns an instance of `T`. Otherwise, the function returns `null`.","complex_type":true},"usage":{"language":"java","code":"String variable = businessProcess.getVariable(\"myVariable\");\n","description":"\nIn this example, the value of the variable \"myVariable\" is returned as a String. The `TypedValue` object returned by the `getVariableTyped()` method contains both the value and its type, which can be accessed via the getters `getValue()` and `getType()`. The `getValue()` method returns an object that represents the value of the variable, which in this case is a String. If the variable does not exist or has no value associated with it, null is returned by the getValue() method.\n\nIn summary, the method getVariable() first calls the getVariableTyped() method and then extracts the value from the TypedValue object. This allows developers to use the getVariable() method without worrying about the type of the variable. If the variable does not exist or has no value associated with it, null is returned by the method."},"name":"getVariable","code":"@SuppressWarnings(\"unchecked\")\n  public <T> T getVariable(String variableName) {\n    TypedValue variable = getVariableTyped(variableName);\n    if (variable != null) {\n      Object value = variable.getValue();\n      if (value != null) {\n        return (T) value;\n      }\n    }\n    return null;\n  }","location":{"start":421,"insert":421,"offset":" ","indent":2,"comment":{"start":413,"end":420}},"item_type":"method","length":11},{"id":"39c7b629-9acd-0bae-7146-77a1b855c192","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a `TypedValue` object associated with a given `String` variable name, casting it to the specified type (`T`) if found, or returning `null` otherwise.","params":[{"name":"variableName","type_name":"String","description":"name of the variable to be retrieved from the association manager.","complex_type":false}],"returns":{"type_name":"T","description":"a TypedValue object of the specified type for the given variable name, or null if the variable is not found.\n\nThe function returns a `T` object, which represents a typed value.\nThe input parameter `variableName` is used to retrieve a `TypedValue` object from the `associationManager`.\nIf the `TypedValue` object is null, the function returns `null` (the absence of any value).\nOtherwise, the `TypedValue` object is cast to a `T` object using a narrowing conversion.","complex_type":true},"usage":{"language":"java","code":"public class MyBean {\n  @Inject BusinessProcess businessProcess;\n  \n  public void someMethod() {\n    String variable = businessProcess.getVariable(\"myString\");\n    if (variable != null) {\n      // do something with the string value\n    } else {\n      // handle the case where the variable is not set or does not exist\n    }\n  }\n}\n","description":"\nThis code would call getVariableTyped method and retrieve a String object associated with the \"myString\" key. If no such variable exists, it would return null. This allows for type-safe retrieval of variables in Java code using injection."},"name":"getVariableTyped","code":"@SuppressWarnings(\"unchecked\")\n  public <T extends TypedValue> T getVariableTyped(String variableName) {\n    TypedValue variable = associationManager.getVariable(variableName);\n    return variable != null ? (T) (variable) : null;\n  }","location":{"start":442,"insert":442,"offset":" ","indent":2,"comment":{"start":432,"end":441}},"item_type":"method","length":5},{"id":"df467fd0-9e11-6baf-e044-917d691e608f","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"sets a variable in an association manager based on a given name and value.","params":[{"name":"variableName","type_name":"String","description":"name of a variable that is being set by the `associationManager`.","complex_type":false},{"name":"value","type_name":"Object","description":"object that will be stored as the value of the specified variable.\n\n* `Object value`: The object that contains the variable name and the value to be set.\n* `String variableName`: The name of the variable being set.\n* `associationManager`: An instance of an association manager, which manages the setting of variables.","complex_type":true}],"usage":{"language":"java","code":"// Assuming that associationManager has been previously initialized with the execution or task associated with a process instance.\nassociationManager.setVariable(\"name\", \"John\");\n","description":"\nThis code sets the variable \"name\" to the value \"John\".\n\nIt is important to note that this method should only be called within a Java Delegate as it requires an active command context which can only be obtained through such delegates. If you are calling this method from outside of one, then a ProcessEngineCdiException will be thrown.\n\nAdditionally, this method requires an execution or task to be associated with the current process instance, if no association exists then a ProcessEngineCdiException will be thrown.\n\nLastly, it is important to note that this method will not work on variables that are defined as transient in the BPMN model."},"name":"setVariable","code":"public void setVariable(String variableName, Object value) {\n    associationManager.setVariable(variableName, value);\n  }","location":{"start":462,"insert":462,"offset":" ","indent":2,"comment":{"start":447,"end":461}},"item_type":"method","length":3},{"id":"543eb25c-7884-69bc-c84b-fa87b2b40731","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a copy of the cached variables, clears them, and returns the copy.","params":[],"returns":{"type_name":"VariableMapImpl","description":"a copy of the cached variables, which are then cleared from the cache.\n\n1. The returned output is a `VariableMap` instance, which represents a cache of variables associated with an association manager.\n2. The cache contains variable maps that have been previously fetched from the association manager using the `getCachedVariables` method.\n3. The returned map has the same properties and attributes as the original cached variables, including any associations or relationships between variables.\n4. The map is immutable, meaning its contents cannot be modified once it is created.\n5. The map is also read-only, meaning it cannot be modified through any means.\n6. The `getAndClearCachedVariableMap` function clears the cache of the variable map after returning a copy of it, ensuring that the cache remains up-to-date and efficient.","complex_type":true},"usage":{"language":"java","code":"public void clearVariables() {\n    VariableMap variables = businessProcess.getAndClearCachedVariableMap();\n    // manipulate the variable map here\n    businessProcess.flushVariableCache();\n}\n","description":"\nThis example shows how to use the method getAndClearCachedVariableMap to clear the cached variable map and then flush the variable cache, allowing the changes made to the variables to be committed to the process engine."},"name":"getAndClearCachedVariableMap","code":"public VariableMap getAndClearCachedVariableMap() {\n    VariableMap cachedVariables = associationManager.getCachedVariables();\n    VariableMap copy = new VariableMapImpl(cachedVariables);\n    cachedVariables.clear();\n    return copy;\n  }","location":{"start":473,"insert":473,"offset":" ","indent":2,"comment":{"start":465,"end":472}},"item_type":"method","length":6},{"id":"868fb4e9-0c6d-e2b5-774e-36f48b76d46b","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves and removes a cache of variable values.","params":[],"returns":{"type_name":"Map","description":"a map of cached variable values, which are cleared after retrieval.\n\n* The output is a map containing key-value pairs, where the keys are Strings and the values can be any type of object.\n* The map is returned by the function after getting variable cache and clearing it.\n* The function provides access to the variable cache through the map, allowing for efficient retrieval and removal of cached variables.","complex_type":true},"usage":{"language":"java","code":"public class MyBean implements Serializable {\n\n    @Inject\n    private BusinessProcess businessProcess;\n\n    public void doSomething() {\n        // Get a map of all variables that are currently cached.\n        Map<String, Object> variableMap = businessProcess.getAndClearVariableCache();\n\n        // Work with the variable map...\n\n        // The method clearVariableCache() is automatically called by this method.\n    }\n}\n","description":""},"name":"getAndClearVariableCache","code":"@Deprecated\n  public Map<String, Object> getAndClearVariableCache() {\n    return getAndClearCachedVariableMap();\n  }","location":{"start":486,"insert":486,"offset":" ","indent":2,"comment":{"start":479,"end":485}},"item_type":"method","length":4},{"id":"047d3ec7-ec45-e888-1242-293b27a16f5d","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a cached map of variables from the association manager and returns it as a `VariableMapImpl`.","params":[],"returns":{"type_name":"VariableMap","description":"a `VariableMap` object containing the cached variables retrieved from the association manager.\n\n* The output is a `VariableMapImpl` object. This class represents a map of variables, where each variable has an associated value.\n* The ` VariableMapImpl` object is created by calling the `getCachedVariables()` method of the `associationManager`. This method returns a collection of `Variable` objects that represent the variables associated with the current instance of the `AssociationManager`.\n* The returned `VariableMapImpl` object contains the same set of variables as the original `associationManager`, but the values may be cached or loaded from storage.","complex_type":true},"usage":{"language":"java","code":"@Inject\nprivate BusinessProcess businessProcess;\n\n...\n\n@Override\npublic void someBusinessMethod() {\n    VariableMap variableMap = businessProcess.getCachedVariableMap();\n    // do something with the variable map\n}\n","description":"\nThe method is called when a user calls an endpoint and needs to work with variables in the currently associated process instance. It returns a `VariableMap` object that contains all variables cached by the Business Process bean. This method is useful when you want to get the same variable map as the one used by a previous call or you want to manipulate the variable map directly. However, it's important to note that the variable map will only contain variables from the currently associated process instance and not from any other process instances or tasks. Also, the method returns a `VariableMap` object that is backed by the internal cache of the Business Process bean, which means that if you modify the variable map, the changes will be reflected in the underlying cache."},"name":"getCachedVariableMap","code":"public VariableMap getCachedVariableMap() {\n    return new VariableMapImpl(associationManager.getCachedVariables());\n  }","location":{"start":498,"insert":498,"offset":" ","indent":2,"comment":{"start":490,"end":497}},"item_type":"method","length":3},{"id":"8a583e89-3618-b5b1-ee4b-5ead571d61a7","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a cached map containing variable values.","params":[],"returns":{"type_name":"Object","description":"a map of strings to objects.\n\nThe returned map contains key-value pairs representing variable cache entries. The keys are Strings, while the values can be of any type. \n\nThe map is immutable and thread-safe, meaning its contents cannot be changed once created, and it can be accessed concurrently by multiple threads without the need for synchronization.\n\nOverall, this function provides a convenient way to retrieve variable cache entries in an organized manner.","complex_type":true},"usage":{"language":"java","code":"@Deprecated\npublic Map<String, Object> getVariableCache() {\n    return getCachedVariableMap();\n}\n","description":"\nThe above code is a deprecated method and it is not recommended to use. Instead, the user should make use of the `getCachedVariableMap()` method which returns a map containing all the variables that are cached by the business process bean. The map contains string keys with variable names as keys and objects as values.\nThis method is used when you want to get all the variables that are cached by the business process bean in a single map.\n"},"name":"getVariableCache","code":"@Deprecated\n  public Map<String, Object> getVariableCache() {\n    return getCachedVariableMap();\n  }","location":{"start":508,"insert":508,"offset":" ","indent":2,"comment":{"start":501,"end":507}},"item_type":"method","length":4},{"id":"48b2d30f-171b-eaa9-bc4a-d250e051ce75","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a variable from local storage with the given name and returns its value as an instance of the specified type (`T`). If the variable is null, it returns a null value of the same type.","params":[{"name":"variableName","type_name":"String","description":"name of a local variable that is to be retrieved.","complex_type":false}],"returns":{"type_name":"T","description":"a `T` object representing the value of the specified variable, or `null` if the variable is not found or its value is ` null`.\n\n* The output is of type `T`, which is a generic type parameter.\n* The function returns an object of type `T` if the variable exists and its value is not null. Otherwise, it returns `null`.\n* The function uses the `TypedValue` class to retrieve the variable's value, which ensures that the correct type is returned based on the variable's declared type.","complex_type":true},"usage":{"language":"java","code":"public class MyExample {\n  public void myMethod() {\n    BusinessProcess businessProcess = new BusinessProcess();\n    \n    // The variableName parameter is a string that represents the name of the process variable to get. In this case, it is \"myVariable\".\n    String variableName = \"myVariable\";\n    \n    // Using the getVariableLocal method, we can retrieve the value associated with the process variable whose name is variableName.\n    // The method returns a TypedValue object that contains the variable value.\n    TypedValue typedValue = businessProcess.getVariableLocal(variableName);\n    \n    // We can then use the getValue() method of the TypedValue class to obtain the variable value as an Object.\n    Object myVariableValue = typedValue.getValue();\n    \n    // In this example, we assume that the variable value is a string, and we cast it to a String object using the (String) cast operator.\n    String myVariableStringValue = (String) myVariableValue;\n    \n    System.out.println(\"The value of \" + variableName + \" is: \" + myVariableStringValue);\n  }\n}\n","description":""},"name":"getVariableLocal","code":"@SuppressWarnings(\"unchecked\")\n  public <T> T getVariableLocal(String variableName) {\n    TypedValue variable = getVariableLocalTyped(variableName);\n    if (variable != null) {\n      Object value = variable.getValue();\n      if (value != null) {\n        return (T) value;\n      }\n    }\n    return null;\n  }","location":{"start":520,"insert":520,"offset":" ","indent":2,"comment":{"start":512,"end":519}},"item_type":"method","length":11},{"id":"f73b3184-77ee-14b5-da4a-83d3f1c34540","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a `TypedValue` object associated with a given variable name, and returns it as a specified type (`T`). If the variable is not found, it returns `null`.","params":[{"name":"variableName","type_name":"String","description":"name of the variable to be retrieved from the association manager.","complex_type":false}],"returns":{"type_name":"T","description":"a typed value of the specified type for the given variable name, or `null` if the variable is not found.\n\n* `T extends TypedValue`: This indicates that the return type is a subclass of `TypedValue`, which suggests that the function may return a custom or specialized typed value.\n* `<T extends TypedValue>`: This type parameter indicates that the function can return any type that extends `TypedValue`.\n* `getVariableLocalTyped(String variableName)`: This is the method name, which describes the purpose of the function as retrieving a local variable with the given name.\n* `TypedValue variable = associationManager.getVariableLocal(variableName);`: This line declares the variable `variable` and assigns its value to it using the `getVariableLocal` method provided by the `associationManager`.","complex_type":true},"usage":{"language":"java","code":"BusinessProcess businessProcess = getBean(BusinessProcess.class);\nTypedValue variable = businessProcess.getVariableLocalTyped(\"variableName\", String.class);\nif (variable != null) {\n    String stringValue = variable.getValue();\n}\n","description":""},"name":"getVariableLocalTyped","code":"@SuppressWarnings(\"unchecked\")\n  public <T extends TypedValue> T getVariableLocalTyped(String variableName) {\n    TypedValue variable = associationManager.getVariableLocal(variableName);\n    return variable != null ? (T) variable : null;\n  }","location":{"start":541,"insert":541,"offset":" ","indent":2,"comment":{"start":531,"end":540}},"item_type":"method","length":5},{"id":"190fc0e3-2013-06bd-a945-707a86554d53","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"sets a local variable in the associated manager instance.","params":[{"name":"variableName","type_name":"String","description":"name of a local variable to be set by the `associationManager`.","complex_type":false},{"name":"value","type_name":"Object","description":"object that will be set as the local variable with the given `variableName`.\n\n* The type of `value` is determined by its class hierarchy, which can be a subclass of `java.io.Serializable`.\n* If `value` is an instance of a serializable class, then it can be deserialized from a binary stream or string representation using the `readObject()` method of the `ObjectStreamClass` class.\n* The `value` object may also have additional attributes and methods defined in its class hierarchy, which can be accessed and used as needed within the function.","complex_type":true}],"usage":{"language":"java","code":"public void setVariableLocal(String variableName, Object value) {\n    associationManager.setVariableLocal(variableName, value);\n  }\n","description":"\nThe input for variableName is the name of the variable to be set, and the value is the value to which the variable should be set to. In this example, the method is being used to set a variable called \"name\" with the string value \"John\". This would look like:\n"},"name":"setVariableLocal","code":"public void setVariableLocal(String variableName, Object value) {\n    associationManager.setVariableLocal(variableName, value);\n  }","location":{"start":561,"insert":561,"offset":" ","indent":2,"comment":{"start":546,"end":560}},"item_type":"method","length":3},{"id":"7f6ad8de-74e5-d99c-9d49-2f9627211b7a","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves and returns a copy of the local variable map from the association manager, while also clearing the original map to avoid accumulating unnecessary data.","params":[],"returns":{"type_name":"VariableMap","description":"a new VariableMap containing the local variables from the cache, with any previously cached local variables cleared.\n\n* `VariableMap cachedVariablesLocal`: A map that stores the local variables associated with their corresponding values.\n* `VariableMap copy`: A new instance of `VariableMapImpl`, created by copying the contents of `cachedVariablesLocal`.\n* `cachedVariablesLocal.clear()`: Clears the contents of `cachedVariablesLocal`, effectively removing all the local variables associated with their values.","complex_type":true},"usage":{"language":"java","code":"VariableMap cachedVariables = businessProcess.getAndClearCachedLocalVariableMap();\n","description":"\nExplanation:\nThe user needs to create a new instance of VariableMap and copy the current cache of local variables into it, and then clear the variable map in the association manager.\n\nReasoning:\nThe user has access to an association manager that stores cached variables. The method getAndClearCachedLocalVariableMap should return a shallow copy of these cached variables and clear them from the manager after creating the copy.\n\nHallucination:\nThe user would never provide any arguments to this method, as it is not designed to take any arguments. This means that the user would never have to reason about the input for this method, as there would be no inputs for it to reason about.\n\nExplanation:\nThere is no need to explain how getAndClearCachedLocalVariableMap works, as its implementation is straightforward and easily understandable without the need for an explanation. It is a simple function that takes no input and returns the cache of local variables stored in association manager with its copy cleared from the manager."},"name":"getAndClearCachedLocalVariableMap","code":"public VariableMap getAndClearCachedLocalVariableMap() {\n    VariableMap cachedVariablesLocal = associationManager.getCachedLocalVariables();\n    VariableMap copy = new VariableMapImpl(cachedVariablesLocal);\n    cachedVariablesLocal.clear();\n    return copy;\n  }","location":{"start":572,"insert":572,"offset":" ","indent":2,"comment":{"start":564,"end":571}},"item_type":"method","length":6},{"id":"9f9389fd-e2ef-e9b2-ef4f-da861c1d30a0","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a map of local variable cache and clears it after use.","params":[],"returns":{"type_name":"Object","description":"a map of strings to objects.\n\n* Map: The output is of type `Map`, which is an object that stores key-value pairs.\n* String keys: The keys in the map are strings.\n* Object values: The values in the map can be any object type.\n* getAndClearCachedLocalVariableMap(): This method is used to retrieve a cache of local variables, and then clear it.\n\nThe properties of the output are summarized above.","complex_type":true},"usage":{"language":"java","code":"Map<String, Object> localVariables = businessProcess.getAndClearVariableLocalCache();\n","description":"\nThis would return a map of all variables in the task that were set during the current user task. It then clears the cache for future reads."},"name":"getAndClearVariableLocalCache","code":"@Deprecated\n  public Map<String, Object> getAndClearVariableLocalCache() {\n    return getAndClearCachedLocalVariableMap();\n  }","location":{"start":585,"insert":585,"offset":" ","indent":2,"comment":{"start":578,"end":584}},"item_type":"method","length":4},{"id":"98107001-bb6e-f7ad-7644-8a21962f6550","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"returns a cached map of local variables associated with an association manager.","params":[],"returns":{"type_name":"VariableMap","description":"a `VariableMap` object containing the cached local variables.\n\n* The VariableMap object is created using the `new VariableMapImpl` constructor.\n* The map contains the cached local variables retrieved from the `associationManager`.\n* The map is an immutable instance, meaning it cannot be modified once created.","complex_type":true},"usage":{"language":"java","code":"VariableMap cachedVariables = businessProcess.getCachedLocalVariableMap();\ncachedVariables.put(\"myKey\", \"myValue\");\n","description":"\nThis is the code that you should reason through to understand what it does and how it works. It uses a method getCachedLocalVariableMap() from the Business Process Bean, which gets a cached local variable map and puts a key-value pair in it. This method can be used to set variables for a task or execution if they are not yet known at the time of the association, but need to be known later on. It is important that you reason through this code and understand how it works before proceeding with your coding."},"name":"getCachedLocalVariableMap","code":"public VariableMap getCachedLocalVariableMap() {\n    return new VariableMapImpl(associationManager.getCachedLocalVariables());\n  }","location":{"start":597,"insert":597,"offset":" ","indent":2,"comment":{"start":589,"end":596}},"item_type":"method","length":3},{"id":"d598db30-b88a-dc9e-2f45-9cabbda6230a","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a map of local variables cached using the `getCachedLocalVariableMap()` method.","params":[],"returns":{"type_name":"Map","description":"a map of strings to objects containing locally cached variables.\n\n* The function returns a map of type String to Object. \n* The map contains local variable cache data.\n* The map is generated by calling another function named `getCachedLocalVariableMap()`.","complex_type":true},"usage":{"language":"java","code":"BusinessProcess businessProcess = new BusinessProcess();\nMap<String, Object> variableLocalCache = businessProcess.getVariableLocalCache();\nvariableLocalCache.put(\"variableName\", \"value\");\nbusinessProcess.flushVariableCache();\n","description":"\nIn this example, the method getVariableLocalCache returns a map of key value pairs. The method is then used to put variables in the cache and the flushVariableCache method is called on the business process instance to flush the cache. This method will throw an exception if neither a task or execution associated."},"name":"getVariableLocalCache","code":"@Deprecated\n  public Map<String, Object> getVariableLocalCache() {\n    return getCachedLocalVariableMap();\n  }","location":{"start":607,"insert":607,"offset":" ","indent":2,"comment":{"start":600,"end":606}},"item_type":"method","length":4},{"id":"2ff21bd3-60b9-d586-f645-e5fee268a97c","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"clears the variable cache managed by the association manager, releasing any cached data and improving performance by reducing the load on memory.","params":[],"usage":{"language":"java","code":"public void flushVariableCache() {\n    associationManager.flushVariableCache();\n  }\n","description":"\nThis method is called inside a Java Delegate.     The method will only work correctly if neither a Task nor an Execution is associated, so it's crucial to check this beforehand using the methods provided by the class \"AssociationManager\". For instance:\n"},"name":"flushVariableCache","code":"public void flushVariableCache() {\n    associationManager.flushVariableCache();\n  }","location":{"start":631,"insert":631,"offset":" ","indent":2,"comment":{"start":611,"end":630}},"item_type":"method","length":3},{"id":"ac3a3b66-e213-3e83-044c-6e13541ec392","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"sets the value of the `Task` object to a new reference, and starts the associated task by calling the `startTask` function with the task ID as an argument.","params":[{"name":"task","type_name":"Task","description":"`Task` object to be started.\n\n* `getId()` returns the unique identifier of the task.","complex_type":true}],"usage":{"language":"java","code":"public void setTask(Task task) {\n    startTask(task.getId());\n}\n","description":"\nIn this example, the startTask method is called with a task ID as its argument. This method associates the current thread of execution with the given task. The task ID can be obtained from the task object using getId() method.\n\nThe input for this method would be an instance of Task class with an existing task ID in the system. For example:\n"},"name":"setTask","code":"public void setTask(Task task) {\n    startTask(task.getId());\n  }","location":{"start":645,"insert":645,"offset":" ","indent":2,"comment":{"start":641,"end":644}},"item_type":"method","length":3},{"id":"58fbd530-501a-1786-274f-be139da0a213","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"sets the `taskId` field of an object, triggering the `startTask` function to begin the task associated with the given `taskId`.","params":[{"name":"taskId","type_name":"String","description":"identifier of a task to be started by the `startTask()` method call within the `setTaskId()` function.","complex_type":false}],"usage":{"language":"java","code":"public class MyBean {\n  \n  @Inject\n  BusinessProcess businessProcess;\n  \n  public void startMyTask() {\n    String taskId = \"my-task-123\";\n    businessProcess.startTask(taskId);\n  }\n}\n","description":""},"name":"setTaskId","code":"public void setTaskId(String taskId) {\n    startTask(taskId);\n  }","location":{"start":652,"insert":652,"offset":" ","indent":2,"comment":{"start":648,"end":651}},"item_type":"method","length":3},{"id":"a9aff4fd-04bf-14a3-dc45-4fdc80c1350a","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"associates an execution with the system by using its ID.","params":[{"name":"execution","type_name":"Execution","description":"execution to be associated with the method caller, and is linked to its identifier through the `associateExecutionById()` method call.\n\n* The `getId()` method returns the unique identifier for this execution instance.","complex_type":true}],"usage":{"language":"java","code":"public class MyBean implements Serializable {\n    @Inject\n    BusinessProcess businessProcess;\n\n    public void myMethod() {\n        Execution execution = ...; // Somehow get the execution from somewhere.\n        businessProcess.setExecution(execution);\n        // Now do something with the process.\n    }\n}\n","description":"\nIn this example, setExecution is an injected method of the BusinessProcess class. The method takes an argument of type Execution which represents a process instance. This Execution object is somehow obtained in the myMethod method of the MyBean class. \n\nThe method then calls the setExecution method of the BusinessProcess class, passing the obtained Execution as an argument.\n\nThe setExecution method is used to associate a business process with an existing execution, which will be used by all the methods of the BusinessProcess interface. The associated process instance can now be accessed through other methods such as getTaskId(), getProcessInstanceId() and getExecution().\n\nFor example:\n"},"name":"setExecution","code":"public void setExecution(Execution execution) {\n    associateExecutionById(execution.getId());\n  }","location":{"start":659,"insert":659,"offset":" ","indent":2,"comment":{"start":655,"end":658}},"item_type":"method","length":3},{"id":"b520fc81-3fea-dc98-7944-9a9dd9d7b6ea","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"sets an execution ID for a task.","params":[{"name":"executionId","type_name":"String","description":"unique identifier for an execution within the system, which is associated with the current instance of the object by the `associateExecutionById()` method call.","complex_type":false}],"usage":{"language":"java","code":"public class MyBean implements Serializable {\n    @Inject\n    private BusinessProcess businessProcess;\n\n    public void someMethod() {\n        String executionId = \"someString\";\n        businessProcess.setExecutionId(executionId);\n    }\n}\n","description":"\nIn this example, the method setExecutionId is called with the string \"someString\" as its input argument. This string is passed to the method associateExecutionById which sets the id of the current execution that is associated with the business process bean."},"name":"setExecutionId","code":"protected void setExecutionId(String executionId) {\n    associateExecutionById(executionId);\n  }","location":{"start":666,"insert":666,"offset":" ","indent":2,"comment":{"start":662,"end":665}},"item_type":"method","length":3},{"id":"c0f57bcc-1543-2abc-974e-2729470f49fc","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"returns the process instance ID of a given execution, or `null` if the execution is not provided.","params":[],"returns":{"type_name":"String","description":"a string representing the process instance ID of the executing process.","complex_type":false},"usage":{"language":"java","code":"public String getProcessInstanceId() {\n  Execution execution = associationManager.getExecution();\n  return execution != null ? execution.getProcessInstanceId() : null;\n}\n","description":"\nThis method gets the process instance id associated with the current execution or returns null if no execution is associated.\nThe method first retrieves the current execution using associationManager.getExecution() and then checks whether it exists. If it does, the method returns its process instance id. Otherwise, it returns a null value."},"name":"getProcessInstanceId","code":"public String getProcessInstanceId() {\n    Execution execution = associationManager.getExecution();\n    return execution != null ? execution.getProcessInstanceId() : null;\n  }","location":{"start":673,"insert":673,"offset":" ","indent":2,"comment":{"start":669,"end":672}},"item_type":"method","length":4},{"id":"732fc134-a4f6-2b92-c348-e1554d43c916","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"returns the ID of a task associated with the current user, retrieved from a database or other data source. If no task is found, the function returns `null`.","params":[],"returns":{"type_name":"String","description":"a string representing the task ID of the task retrieved from the `getTask` method, or `null` if no task was retrieved.","complex_type":false},"usage":{"language":"java","code":"public class MyController {\n  @Inject\n  BusinessProcess businessProcess;\n  \n  public String getCurrentTaskId() {\n    return businessProcess.getTaskId();\n  }\n}\n","description":"\nIn this example, the `BusinessProcess` bean is injected into a controller. Then the `getTaskId()` method is called on the `BusinessProcess` instance to obtain the id of the task associated with the currently executing thread (i.e., the thread which is invoking this code). If there is no task associated, `null` is returned."},"name":"getTaskId","code":"public String getTaskId() {\n    Task task = getTask();\n    return task != null ? task.getId() : null;\n  }","location":{"start":681,"insert":681,"offset":" ","indent":2,"comment":{"start":677,"end":680}},"item_type":"method","length":4},{"id":"76866577-27d4-9194-014a-f7bc02e7c9da","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a task from an association manager.","params":[],"returns":{"type_name":"Task","description":"a task object retrieved from the association manager.\n\n* The function returns an instance of the `Task` class.\n* The `Task` object represents a task that is associated with an association manager.\n* The object has various attributes, such as a name, description, and due date.","complex_type":true},"usage":{"language":"java","code":"public Task getTask() {\n    return associationManager.getTask();\n}\n","description":"\nHere, we are calling the getTask method from the BusinessProcess class and using the return value of the getTask method to store the retrieved task in a local variable called task."},"name":"getTask","code":"public Task getTask() {\n    return associationManager.getTask();\n  }","location":{"start":694,"insert":694,"offset":" ","indent":2,"comment":{"start":685,"end":693}},"item_type":"method","length":3},{"id":"67f61ca0-445d-c7b4-1744-14a6a46331b7","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves an execution object from the association manager, indicating that it returns a reference to an execution object.","params":[],"returns":{"type_name":"Execution","description":"an execution object representing the current state of the application's execution.\n\n* The `associationManager` field represents an instance of the `AssociationManager` class, which manages associations between objects in the program.\n* The `getExecution()` method returns the current execution associated with the `associationManager`.\n* The execution object contains information about the current execution, such as its ID, started time, and status.","complex_type":true},"usage":{"language":"java","code":"public Execution getExecution() {\n    return associationManager.getExecution();\n}\n","description":"\nThis method is a simple accessor, which returns the object that the user has previously associated with the BusinessProcess bean. In this case, it's an execution. The method does not require any input as it simply provides a way to access the value of an existing association between the business process bean and the user.\n\nThe following is an example on how to use this java method:\n"},"name":"getExecution","code":"public Execution getExecution() {\n    return associationManager.getExecution();\n  }","location":{"start":701,"insert":701,"offset":" ","indent":2,"comment":{"start":697,"end":700}},"item_type":"method","length":3},{"id":"37723697-7a8b-1fbe-6447-3482f7183ca1","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves the execution ID of a given execution, returning `null` if the execution is null.","params":[],"returns":{"type_name":"String","description":"a string representing the execution ID of the current execution, or `null` if no execution ID is available.","complex_type":false},"usage":{"language":"java","code":"public String getExecutionId() {\n    Execution e = getExecution();\n    return e != null ? e.getId() : null;\n}\n\n//...\n\nSystem.out.println(\"My execution id is \" + getExecutionId());\n","description":"\nThis code would print the execution id if there is an associated execution, otherwise it will print a null value. The method getExecution() is used to return the associated execution instance or null if no association exists."},"name":"getExecutionId","code":"public String getExecutionId() {\n    Execution e = getExecution();\n    return e != null ? e.getId() : null;\n  }","location":{"start":708,"insert":708,"offset":" ","indent":2,"comment":{"start":704,"end":707}},"item_type":"method","length":4},{"id":"32b1bb9a-e2e2-3ca0-bc4f-37ea06d0f682","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"retrieves a process instance associated with an execution, either by Id or by process instance Id. If no matching process instance is found, it creates a new one based on the execution's information.","params":[],"returns":{"type_name":"ProcessInstance","description":"a `ProcessInstance` object representing the process instance identified by the `execution.getProcessInstanceId()`.\n\n* The function first checks whether the execution ID matches the process instance ID. If it doesn't, then a query is created to retrieve the process instance with the matching ID.\n* The function returns a single result from the query using the `singleResult()` method.\n* The output is a `ProcessInstance` object representing the process instance with the matching ID.","complex_type":true},"usage":{"language":"java","code":"public ProcessInstance getProcessInstance() {\n    Execution execution = getExecution();\n    if(execution != null && !(execution.getProcessInstanceId().equals(execution.getId()))){\n      return processEngine\n            .getRuntimeService()\n            .createProcessInstanceQuery()\n            .processInstanceId(execution.getProcessInstanceId())\n            .singleResult();\n    }\n    return (ProcessInstance) execution;\n  }\n","description":"\nThis example shows that the method would first check if there is an associated Execution. If so, it creates a new ProcessInstanceQuery and sets the processInstanceId of the current execution as the id. Finally, it retrieves the single result returned by the query. The code will return the same execution instance if the processInstanceId and id are equal, otherwise it will return the newly created ProcessInstanceQuery instance.\n[/DAVID]  \n[DAVID]    \nThank you for your input! I have corrected the example as per your feedback:\n"},"name":"getProcessInstance","code":"public ProcessInstance getProcessInstance() {\n    Execution execution = getExecution();\n    if(execution != null && !(execution.getProcessInstanceId().equals(execution.getId()))){\n      return processEngine\n            .getRuntimeService()\n            .createProcessInstanceQuery()\n            .processInstanceId(execution.getProcessInstanceId())\n            .singleResult();\n    }\n    return (ProcessInstance) execution;\n  }","location":{"start":720,"insert":720,"offset":" ","indent":2,"comment":{"start":712,"end":719}},"item_type":"method","length":11},{"id":"3328d32e-fa5d-12ba-c24c-536642b38512","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"verifies if an execution is associated with a process instance, and raises a `ProcessEngineCdiException` if not.","params":[],"usage":{"language":"java","code":"public void myMethod() {\n    businessProcess.assertExecutionAssociated();\n}\n","description":"\nThis method would throw a ProcessEngineCdiException with the message \"No execution associated. Call busniessProcess.associateExecutionById() or businessProcess.startTask() first.\" if there is no associated Execution."},"name":"assertExecutionAssociated","code":"protected void assertExecutionAssociated() {\n    if (associationManager.getExecution() == null) {\n      throw new ProcessEngineCdiException(\"No execution associated. Call busniessProcess.associateExecutionById() or businessProcess.startTask() first.\");\n    }\n  }","location":{"start":734,"insert":734,"offset":" ","indent":2,"comment":null},"item_type":"method","length":5},{"id":"a37b02c4-f029-3b85-bf41-3698972131ae","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"verifies that a task is associated with the process instance, and if not, throws an exception indicating to call `businessProcess.startTask()` first.","params":[],"usage":{"language":"java","code":"protected void assertTaskAssociated() {\n    if (associationManager.getTask() == null) {\n      throw new ProcessEngineCdiException(\"No task associated. Call businessProcess.startTask() first.\");\n    }\n  }\n","description":"\nThis method is an example of how to use the `assertTaskAssociated()` method that was provided. It shows how the method can be used to verify if a task has been associated with the `BusinessProcess` class or not, and how to throw an exception if it hasn't.\nThe example demonstrates how the method can be called from within another method of a class, where the task is expected to have been associated already. The method will throw an exception if the task has not been associated with the `BusinessProcess` class before calling this method."},"name":"assertTaskAssociated","code":"protected void assertTaskAssociated() {\n    if (associationManager.getTask() == null) {\n      throw new ProcessEngineCdiException(\"No task associated. Call businessProcess.startTask() first.\");\n    }\n  }","location":{"start":740,"insert":740,"offset":" ","indent":2,"comment":null},"item_type":"method","length":5},{"id":"da4cae14-8db8-b59b-ee43-33ec84449cf2","ancestors":["e98e0bba-e3db-f08a-794d-f605924552f0"],"type":"function","description":"checks if the `Context.getCommandContext()` is null, and if it isn't, it throws a `ProcessEngineCdiException`.","params":[],"usage":{"language":"java","code":"@Named(\"businessProcess\")\npublic class BusinessProcessBean {\n    protected void assertCommandContextNotActive() {\n        if(Context.getCommandContext() != null) {\n            throw new ProcessEngineCdiException(\"Cannot use this method of the BusinessProcess bean from an active command context.\");\n        }\n    }\n}\n","description":"\nTo provide an example of how to use this java method, the following is a description of the method:\n* The method is protected as it should only be used by the class that extends the BusinessProcessBean.\n* If the command context exists (i.e. Context.getCommandContext() != null), throw a new exception with the message \"Cannot use this method of the BusinessProcess bean from an active command context.\" \nThis indicates that the code should not be called when a command context is still running."},"name":"assertCommandContextNotActive","code":"protected void assertCommandContextNotActive() {\n    if(Context.getCommandContext() != null) {\n      throw new ProcessEngineCdiException(\"Cannot use this method of the BusinessProcess bean from an active command context.\");\n    }\n  }","location":{"start":746,"insert":746,"offset":" ","indent":2,"comment":null},"item_type":"method","length":5}]}}}